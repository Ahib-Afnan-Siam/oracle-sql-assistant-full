import re
import logging
import json
from datetime import datetime, timedelta
from app.llm_client import call_llm
from app.db_connector import connect_to_source
from app.config import SOURCES

logger = logging.getLogger(__name__)

# -------------------------
# SQL Sanitization & Safety
# -------------------------
def extract_sql(llm_response: str) -> str:
    """
    Extract SQL query from LLM response.
    Cleans code fences and ensures only SQL text is returned.
    """
    if not llm_response:
        return ""

    # Remove all code fences like ```sql ... ```
    cleaned = re.sub(r"```.*?```", "", llm_response, flags=re.DOTALL).strip()
    
    # Remove single-line comments
    cleaned = re.sub(r"--.*", "", cleaned, flags=re.MULTILINE)
    
    # Remove multi-line comments
    cleaned = re.sub(r"/\*.*?\*/", "", cleaned, flags=re.DOTALL)
    
    # Extract SQL starting with SELECT or WITH
    match = re.search(r"((SELECT|WITH)\s+.*?)(?=;|$)", cleaned, re.DOTALL | re.IGNORECASE)
    return match.group(0).strip() if match else ""


def fix_common_typos(sql: str) -> str:
    """Fix common typos in SQL generated by LLM"""
    corrections = {
        r"\bMVL\b": "NVL",
        r"\bSUN\b": "SUM",
        r"\bVEAR\b": "YEAR",
        r"\bEXTRACT\(VEAR\b": "EXTRACT(YEAR",
        r"\bTO_VER\b": "TO_YEAR"
    }
    for pattern, replacement in corrections.items():
        sql = re.sub(pattern, replacement, sql, flags=re.IGNORECASE)
    return sql


def is_sql_safe(sql: str) -> bool:
    """Basic SQL safety validation (block DROP, DELETE, etc.)."""
    if not sql:
        return False
    forbidden = ["DROP", "DELETE", "INSERT", "UPDATE", "ALTER", "TRUNCATE", "CREATE"]
    return not any(re.search(rf"\b{kw}\b", sql, re.IGNORECASE) for kw in forbidden)


# -------------------------
# Schema Info for Prompting
# -------------------------
SCHEMA_INFO = """
Tables and Columns:
- T_ORDC (BUYER_NAME, STYLEPO, STYLE, JOB, FACTORY, POQTY, CUTQTY, SINPUT, SOUTPUT, SHIPQTY, LEFTQTY, FOBP, SHIPDATE)
- EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
- DEPT (DEPTNO, DNAME, LOC)
- T_PROD_DAILY (PROD_DATE, FLOOR_NAME, PRODUCTION_QTY, DEFECT_QTY, AC_WORKING_HOUR)
- T_DAILY_OT (A_DATE, BU_NAME, SECTION_NAME, OT_HOUR, OT_AMOUNT)
- V_TNA_STATUS (BUYER_NAME, JOB_NO, PO_NUMBER, STYLE_REF_NO, SHIPMENT_DATE)
"""

# Map keywords to tables for fallback FROM clause
INTENT_TO_TABLE = {
    "buyer": "T_ORDC",
    "poqty": "T_ORDC",
    "shipqty": "T_ORDC",
    "revenue": "T_ORDC",
    "factory": "T_ORDC",
    "employee": "EMP",
    "dept": "DEPT",
    "production": "T_PROD_DAILY",
    "defect": "T_PROD_DAILY",
    "floor": "T_PROD_DAILY",
    "ot": "T_DAILY_OT",
}


# -------------------------
# Generate SQL
# -------------------------
def generate_sql(user_query: str) -> str:
    """
    Generate a valid Oracle SQL query using LLM, with fallback fixing.
    """
    prompt = f"""
Generate ONE Oracle SQL query for this user question:
"{user_query}"

Schema:
{SCHEMA_INFO}

Rules:
- Return ONLY SQL (no text or comments).
- Use NVL(SUM(...),0) for sums.
- Use FETCH FIRST N ROWS ONLY for top-N queries.
- Avoid semicolons at the end.
- Always include a FROM clause.
- Use TRUNC(SYSDATE) for date calculations.
- Use EXTRACT(YEAR FROM SYSDATE) for year comparisons.
- Use ADD_MONTHS for monthly calculations.
"""

    try:
        llm_response = call_llm(prompt)
    except Exception as e:
        logger.error(f"LLM call failed: {e}")
        return fallback_sql(user_query)

    sql_query = extract_sql(llm_response)
    
    # Fix common typos before validation
    if sql_query:
        sql_query = fix_common_typos(sql_query)
    
    if not sql_query or not sql_query.lower().startswith(("select", "with")):
        logger.warning("LLM returned invalid SQL. Using fallback.")
        return fallback_sql(user_query)

    # Remove trailing semicolon if present
    sql_query = sql_query.rstrip(";")

    # Validate SQL structure
    if " from " not in sql_query.lower():
        logger.warning("Missing FROM clause. Using fallback SQL.")
        return fallback_sql(user_query)

    if not is_sql_safe(sql_query):
        logger.error(f"Unsafe SQL detected: {sql_query}")
        return fallback_sql(user_query)

    logger.info(f"Generated SQL: {sql_query}")
    return sql_query


def fallback_sql(user_query: str) -> str:
    """
    Provide a simple fallback SQL for known patterns if LLM fails.
    """
    user_query_lower = user_query.lower()
    
    # Calculate dynamic dates
    today = datetime.now()
    last_month = today - timedelta(days=30)
    last_week = today - timedelta(days=7)
    
    # Sales-related queries
    if "buyer" in user_query_lower and "shipqty" in user_query_lower:
        return f"""
            SELECT BUYER_NAME, NVL(SUM(SHIPQTY),0) AS TOTAL_SHIPQTY
            FROM T_ORDC
            WHERE SHIPDATE >= TO_DATE('{last_month.strftime('%Y-%m-%d')}', 'YYYY-MM-DD')
            GROUP BY BUYER_NAME
            ORDER BY TOTAL_SHIPQTY DESC FETCH FIRST 5 ROWS ONLY
        """.strip()
    
    # Style-specific queries
    elif "style" in user_query_lower:
        # Extract style from query
        style_match = re.search(r"'([^']*)'", user_query, re.IGNORECASE)
        style = style_match.group(1) if style_match else "OVS123"
        
        return f"""
            SELECT NVL(SUM(POQTY),0) AS POQTY, NVL(SUM(SHIPQTY),0) AS SHIPQTY
            FROM T_ORDC
            WHERE STYLE = '{style}'
            AND EXTRACT(YEAR FROM SHIPDATE) = EXTRACT(YEAR FROM SYSDATE)
        """.strip()
    
    # Revenue queries
    elif "revenue" in user_query_lower:
        # Extract factory from query
        factory_match = re.search(r"'([^']*)'", user_query, re.IGNORECASE)
        factory = factory_match.group(1) if factory_match else "Dhaka Unit-1"
        
        return f"""
            SELECT NVL(SUM(FOBP * SHIPQTY),0) AS REVENUE
            FROM T_ORDC
            WHERE FACTORY = '{factory}'
        """.strip()
    
    # Employee queries
    elif "employee" in user_query_lower or "dept" in user_query_lower:
        # Extract department number
        dept_match = re.search(r'dept\w*\s+(\d+)', user_query_lower)
        deptno = dept_match.group(1) if dept_match else "10"
        
        if "manager" in user_query_lower:
            return f"""
                SELECT E.ENAME, D.DNAME 
                FROM EMP E
                JOIN DEPT D ON E.DEPTNO = D.DEPTNO
                WHERE D.DEPTNO = {deptno} AND E.JOB = 'MANAGER'
            """.strip()
        else:
            return f"""
                SELECT ENAME, JOB, SAL 
                FROM EMP 
                WHERE DEPTNO = {deptno}
            """.strip()
    
    # Production queries
    elif "production" in user_query_lower or "defect" in user_query_lower:
        return f"""
            SELECT SUM(PRODUCTION_QTY) AS TOTAL_PRODUCTION, 
                   SUM(DEFECT_QTY) AS TOTAL_DEFECTS
            FROM T_PROD_DAILY
            WHERE PROD_DATE >= TO_DATE('{last_week.strftime('%Y-%m-%d')}', 'YYYY-MM-DD')
        """.strip()
    
    # Floor queries
    elif "floor" in user_query_lower:
        # Extract date from query
        date_match = re.search(r'\d{4}-\d{2}-\d{2}', user_query)
        date = date_match.group(0) if date_match else today.strftime('%Y-%m-%d')
        
        return f"""
            SELECT FLOOR_NAME, AC_WORKING_HOUR
            FROM T_PROD_DAILY
            WHERE PROD_DATE = TO_DATE('{date}', 'YYYY-MM-DD')
        """.strip()
    
    # Overtime queries
    elif "ot" in user_query_lower:
        if "amount" in user_query_lower:
            # Extract section from query
            section_match = re.search(r"'([^']*)'", user_query, re.IGNORECASE)
            section = section_match.group(1) if section_match else "Line 3"
            
            return f"""
                SELECT SUM(OT_AMOUNT) AS TOTAL_OT_AMOUNT
                FROM T_DAILY_OT
                WHERE SECTION_NAME = '{section}'
            """.strip()
        else:
            # Extract BU name from query
            bu_match = re.search(r"'([^']*)'", user_query, re.IGNORECASE)
            bu = bu_match.group(1) if bu_match else "Unit-A"
            
            return f"""
                SELECT SUM(OT_HOUR) AS TOTAL_OT_HOURS
                FROM T_DAILY_OT
                WHERE BU_NAME = '{bu}'
                AND A_DATE >= TO_DATE('{last_month.strftime('%Y-%m-%d')}', 'YYYY-MM-DD')
            """.strip()
    
    # Default fallback
    return "SELECT 1 FROM DUAL"


# -------------------------
# Execute SQL
# -------------------------
def execute_sql(sql_query: str):
    cfg = SOURCES.get("source_db_1")
    if not cfg:
        return {"error": "No database configuration found."}

    try:
        with connect_to_source(cfg) as conn:
            with conn.cursor() as cur:
                cur.execute(sql_query)
                cols = [col[0].replace('"', '') for col in cur.description]  # Remove double quotes
                rows = cur.fetchall()
                return {"columns": cols, "rows": rows}
    except Exception as e:
        logger.error(f"SQL execution error: {e}")
        return {"error": str(e)}


# -------------------------
# Process User Query
# -------------------------
def process_query(user_query: str):
    # Retry mechanism for LLM timeouts
    for attempt in range(2):
        try:
            sql_query = generate_sql(user_query)
            break
        except Exception as e:
            if "timed out" in str(e) and attempt == 0:
                logger.warning("LLM timeout, retrying...")
                continue
            logger.error(f"SQL generation failed: {e}")
            sql_query = fallback_sql(user_query)
            break
    
    if not sql_query:
        return {"error": "Failed to generate valid SQL."}
    
    # Final validation before execution
    if not sql_query.lower().startswith(("select", "with")) or " from " not in sql_query.lower():
        return {"error": "Invalid SQL structure generated"}
    
    return execute_sql(sql_query)


# -------------------------
# Test (Standalone)
# -------------------------
if __name__ == "__main__":
    test_queries = [
        "List top 5 buyers by SHIPQTY in the last month.",
        "Show total POQTY and SHIPQTY for STYLE 'OVS123' this year.",
        "Get total revenue (FOBP * SHIPQTY) for FACTORY 'Dhaka Unit-1'.",
        "List all employees in department 10.",
        "Show ENAME and SAL of employees with JOB = 'MANAGER'.",
        "Who is the manager of department 20?",
        "Show total PRODUCTION_QTY and DEFECT_QTY from T_PROD_DAILY last week.",
        "List FLOOR_NAME and AC_WORKING_HOUR for 2025-06-20.",
        "Get total OT_AMOUNT for SECTION_NAME 'Line 3'.",
        "Show total OT_HOUR for BU_NAME 'Unit-A' last month.",
    ]
    print("---- SQL GENERATION & EXECUTION TEST ----\n")
    for q in test_queries:
        print(f"User Query: {q}")
        result = process_query(q)
        if "error" in result:
            print(f"Error: {result['error']}")
        else:
            print(f"Columns: {result['columns']}")
            for row in result['rows'][:5]:
                print(row)
        print("\n" + "-" * 50)